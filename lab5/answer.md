1) Комбинация кнопок Ctrl+c генерирует сигнал SIGINT(сигнал говорящий об остановке процесса). После чего команда "trap" перехватывает сигнал, а дальше выполняется команда "echo"(сигнализирует в терминале, что процесс остановлен), после чего идет exit 1.
2) $$ - особая переменная bash'a, является иденификатором текущего процесса
ссылка на каталог, соответствующий текущему процессу /proc/self
Команда ls -l /proc/self - вызвана при помощи нового процесса ls, так же как и команда ls -l /proc/$$, но их pid разные
3) 0 - stdin, 1 - stdout, 2 - stderr
4) Дескриптор изменятся:
	1) вывод stdout будет перенаправлен в файл ls.out
	2) вывод stderr будет перенаправлен в файл ls.err
5) Если мы изменили дескрипторы, то так же именились права. Для stdin -> lr-x, для stdout и stderr -> l-wx
6) Команда exec заменяет процесс, в котором была запущена, а командная оболочка закрывается
7) pos(position) - позиция дескриптор в файле. Записали два слова в файл. Test3 - 5 символов, Test333 - 7 символов, и еще 2 перевода строки после каждого слова => 5+1+7+1 = 14 - значение pos в этом файле
8) Да, это возможно. rm - удаляет ссылку на inode данного файла, но процесс потомок все еще хранит ссылку на нужный inode. Поэтому мы сможем продолжить читать, но я не уверен, что сможет после того, как процесс закончит свою работу. 
